
1주차

180509(화)
[ 1 ] Computer (최우영강사님) 

Calculation : 연산만
Computation : 시스템적인 방법으로 과정을 수행하는 것 연산과정을 저장할 수 있음(좀더 고차원적) 
(가차와 자판기의 차이점을 들어 설명해 주심)

Computer science and engineering
컴퓨터의 소프트웨어를 다루는 학문+컴퓨터라는 물리적 기기를 연구하는 것이 아닌 컴퓨터의 개념과 구조를 이해하고 구현하는 학문

모니터
메인보드
키보드

#컴퓨터는 직류전압. 그래서 교류전압인 220v를 9-12?v의 직류전압으로 바꿔주는 파워서포트가 필요함

Basic computer architecture
*하드웨어의 동작
Memory 
CPU : control unit(program counter) / arithmetic logic unit(사칙연산, 논리연산)
- input이 들어오면 control unit에 저장해서 순서를 기다림. 순서대로 메모리에 가져다주면 arithmetic logic unit에서 처리해서 결과값을 다시 memory에 쌓음. 그것을 output에 보여줌
Input(키보드..) / output(모니터, 스피커, 프린터)


CPU and MicroProcessor
반도체(도체와 부도체 사이에 있는 물질, 특정 조건을 만족했을 때 전기가 흐르는 물질.)

1)X86 이라는 아키텍처는
8080 프로세서(한번에 8비트씩 연산)에서 시작되었다. (비트는 0,1로 이루어진 프로그래밍을 할 수 있는 최소단위)
8086
8088
80286
80386 -32비트

64비트 연산을 하기 위해 인텔이 설계를 다시함

2)AMD64에서 Opteron(64bit)가 64bit시장을 장악. 

3)지금 우리가 사용하는 i 시리즈도 AMD64 기반으로 한 것

* CISC / RISC Architecture
1)CISC 
- 고성능 컴퓨팅에 사용. 
- 전력을 많이 먹는 대신 성능이 빠르다.
2)RISC
- 전력을 적게 먹는 단순한 명령
- 저전력 프로세싱에 사용. 
- 모바일 프로세스
- ARM, SPARC…

* 메모리 : 컴퓨터에서 사용할 수 있도록 정보를 저장하는 공간
- RAM(random access memory) : 자유롭게 읽고 쓸 수 있는 주기억장치. 메모리의 주소로 그 위치에 접근. 같은 시간에 접근(RANDOM access) 
- Read only memory : 전원이 공급되지 않아도 그 정보를 유지하는 주기억장치. 메인보드가 가지고 있는 BIOS, OS, Firmware정보 저장에 쓰임
- 보조기억장치 :  CD, 자기테이프, USB... 메인보드에 떨어져 와이어로 연결되는 것

* OS 
- Window, Linux, IOS, Android…
- 시스템 하드웨어와 응용 소프트웨어의 리소스를 관리하는 시스템소프트웨어(중간다리 역할)
1)Unix
2)Unix-like
3)Linux
- Unix-clone OS
- GNU(Linux가 아닌 것)/Linux
4)Linux-like
5)Windows
- MS-DOS에서 시작함(16bit기반)
-  Vista 이전에는 32비트, 비스타 이후 NT Kernel 6.1부터 64비트 안정적으로 지원.

* Type
- Single-tasking / Multi-tasking
- Single-user / Multi-user

* Patch / Debug
- Patch 프로그램을 수정한다는 의미

* Computational Thinking
- 정답이 정해지지 않은 문제에 대한 해답을 일반화하는 과정
   

- [ ] 알고리즘 답을 만들고 추상화하는 것. 문제 정의를 먼저 해라. 일주일동안 선택했던 순간

Start 버블티가 먹고 싶다 ? true | end

돈이 있는가? 
	4000<예산<5000?  -> 공차에 간다 -> ‘달게 먹고 싶은가?’로 이동
	2500<예산<4900? ->편의점 밀크티 -> End
	예산<1000? -> 데자와 -> End

달게 먹고 싶은가?
	Yes -> 당도100%  -> ‘씹는 걸 먹고 싶은가?’로 이동
	No 아닐 경우 50% 선택 -> ‘씹는 걸 먹고 싶은가?’로 이동

씹는 걸 먹고 싶은가?
오백원 추가해도 총예산<5000?
	Yes -> 타피오카 추가 -> ‘더 추가하고 싶은가?’로 이동
	No -> 그냥 먹는다 -> End

더 추가하고 싶은가?
	Yes -> 오백원 추가해도 총예산<5000? -> 알로에 추가
	No -> 그냥 먹는다 -> End

End

180510(수)
[ 2 ] Pseudo, algo, data(최우영강사님) 

- 다음주 월요일 퀴즈

1. Pseudocode

- 프로그램이나 알고리즘이 수행할 내용을 인간이 이해할 수 있는 언어로 표현하는것. 가짜코드. 
- Pseudocode는 프로그램을 설계할 때 밑그림의 역할을 하게 된다. 목적과 수행과정이 명확해서 코드 수정과 분해가 편리하다. 우리가 하는 코드는 절차지향적이다. 지금 쓰고 있는 객체지향은 좀 다르다. 절차지향은 순서대로 흐르는 느낌이라면, 객체지향은 프로그램에서 중요하다고 생각되는 것 먼저 처리.
-  pseudocode자체가 주석이 될 수 있다. 

* 배포할 때 comment 지우는 툴도 있다. 배포할 때는 지우고 배포하는게 일반적. 
* 그래도 주석다는 습관은 가지면 협업하는데 도움이 된다.
* 자신이 작성할 언어의 스타일에 맞춰서 작성하면 좋다. 

- 슈도코드로 fizzbuss를 만들어보자! : 1 부터 n 까지 반복하면서, 3의 배수는 "fizz" 5의 배수는 "buzz" 15의 배수는 "fizzbuzz" 나머지는 숫자

[내가 한  것]
1. 사용자로부터 숫자 하나를 받아 n에 할당한다
2. 1부터 사용자로부터 입력받은 숫자(number)까지 출력한다
3. A가 3의 배수일 때 “fizz”를 출력
- A를 3으로 나눴을 때 나머지가 0이면 “fizz”를 출력한다
- 3으로 나눴을 때 나머지가 0이 아니면 들어온 값을 그대로 리턴한다
3. b가 5의 배수일때 “buzz”를 출력
- b를 5로 나눴을 때 나머지가 0이면 “buzz”를 출력한다
- 5로 나눴을 때 나머지가 0이 아니면 들어온 값을 그대로 리턴한다
4. C가 15의 배수일 때 “fizz buzz”를 출력한다.
- C를 15로 나눴을 때 나머지가 0이면 “fizz buzz”를 출력한다.
- c를 15로 나눴을 때 나머지가 0이 아니면 들어온 숫자를 그대로 출력한다. 

[강사님 코드]
1. 사용자로부터 숫자 하나를 받아 n에 할당한다
2. 1부터 n까지 숫자를 진행시키면서,
    1. 만약 해당 숫자가 15의 배수라면 “fizzbuzz”를 출력 (큰 공배수 먼저 써야함)
    2. 만약 해당 숫자가 3의 배수라면 “fizz”를 출력
    3. 만약 해당 숫자가 5의 배수라면 “buzz”를 출력
    4. 만약 1,2,3의 경우를 만족시키지 못한경우 해당 숫자를 출력한다

-> 순서를 15, 5, 3으로 바꿔주면 더 효율적. 컴퓨터가 코드를 좀 더 적은 횟수로 읽기 때문. 
3은 33번 읽고 5는 20번읽는데 양 많은 것을 올려주면 좋다. 적은 숫자가 내려가니까.

1. get integer from user ==> num, i == 1
2. WHILE i is less than or equal to num
3. if i is divisible by 15, print "fizzbuzz"
4. if i is divisible by 3, print "fizz"
5. if i is divisible by 5, print "buzz"
6. else, print i

num = input("get number for fizzbuzz: ")
i = 1
for i in range(1,100+1):
	if i % 3 == 0:
		print("fizz")
	elif i % 5 == 0:
		print("buzz")
	elif i % 15 == 0:
		print("fizzbuzz")
	else:
		print(i)


[부가가치세]
- 내가 짠 코드
1. 사용자에게 물건의 가격과 국가코드를 받는다
2. 국가 코드가 한국일 경우,
    1. a += a*0.1, print a
3. 국가 코드가 Japan,
    1. B += b*0.08, print b
4. 국가코드 USA,
    1. print “It depends on states.”
5. 국가코드 UK,
    1. C += c*0.2, print c

1. Get integer from user ==> price, get text from user => nation
2. If nation == Kor, price += price*0.1, print price
3. if else nation == Jap, price += price*0.08, print price
4. if else nation == USA, print “각 주 별로 상이합니다.”
5. if else nation == UK, price += price*0.2, print price
6. Else, print “잘 못 입력하셨습니다.”

- 강사님 짜신 pseudocode 코드
1. get price of item ==> item_price
2. set tax rate (kor == 0.1, jap == 0.08, usa == "depend on state", uk == 0.2)
3. get contry code(example: kor, jap, usa, uk) ==> contry_code
4. tax_rate is matched price with contry_code
5. sales tax is item_price times tax rate
5. total price is item_price plus sales tax


2.  Algorithm

알고리즘의 중요성이 점점 대두되고 있다.
목표를 달성하거나 결과물을 생산하기 위해 필요한 과정.
프로그래밍은 절차지향적이기 때문에 알고리즘이 중요한 것.

Clarity // 다이아몬드와 같은 것? 읽었을 때 읽히는 것

- 시간복잡성 big o notation
1 => constant
log n => logarithmic
n => linear
$n^2$ => quadratic

O(1) : constant
값에 대한 키 또는 인엑스를 알고 있을 경우.
random access와 같이. 바로 떨어지는 것이라 1

O(log n) : logarithmic
배열에서 값을 접근할 때(바로 찾아가는 것이 아니라 0번째부터 순차적으로 찾아가는 것.)
앞 또는 뒤에서 접근이 가능할 경우. (순회가능한 객체)
그래서 1과 n사이에 있다는 의미에서 log n 

O(n) : linear
자료의 수와 시도횟수가 _1:1_ 관계인 경우
(반복문 하나 쓰면 벌어지는 일, n번 반복하기 때문에 n이라고 하는 것)
<pre><pre>result = 0
for i in range(1,10+1):
	for j in range(1,j+1):
		result += j
</pre></pre>

O($n^2$): quadratic
자료의 참조를 이중으로 하게 될 경우
(이 경우까지 가지 않는게 좋음)



